/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package bstset;

/**
 *
 * @author
 */
public class BSTSet {
    private TNode root;

//intializes the BSTSet object to represent the empty set (an empty tree)
    public BSTSet(){
    root=null;    
}
    
//intializes the BSTSet object to represent the set containing all elements in array input, without repetitions    
public BSTSet(int[] input){
    root = new TNode(input[0], null, null);//places the first number in our set at index zero and sets left and right to null
        for(int i=1; i<input.length; i++){
            this.add(input[i]);//uses the add method to copy set in increasing order
        }
}

//Returns true if integer v is an element of BSTSet, false otherwise.
public boolean isIn(int v){
    TNode t=root;
    while(t!=null){
        if(v==t.element)//if v equal to the element
           return true;//return true to indicate that element already exists
        else if(v<t.element)//if v is smaller than the element we're checking
            t=t.left;//look to the left of the tree
        else if(v>t.element)//if v is larger than the element we're checking
            t=t.right; //look to the right of the tree       
    }
    return false;//if not found, we return false
}

//Adds v to this BSTSet if v was not already an element
public void add(int v){
    if(root==null)
        root= new TNode(v,null,null);
    else{
        TNode t = root;
        if(isIn(v)==true)//if  v is already in this BSTSet
            return;//nothing happens
        while(t!=null){
            if(v==t.element)
                return;
            if(v<t.element){//if v is smaller than the element we're checking, we look to the left of the tree
                if(t.left==null){//if nothing is there on the left
                    t.left=new TNode(v,null,null);//we place v there
                }
                else{
                t=t.left;//otherwise, we keep checking to the left until we find a suitable place
                }
            }
            if(v>t.element){//if v is smaller than the element we're checking, we look to the right of the tree
                if(t.right==null){//if nothing is there on the right
                    t.right=new TNode(v,null,null);//we place v there
                }
                else{
                    t=t.right;//otherwise, we keep checking to the right until we find a suitable place
                }
            }   
        }
    }
}
//Remove v from this BSTSet if v was an element of this BSTSet
public boolean remove(int v){
    if(isIn(v)==true){
        remove(v,root);
        return true;
    }
    else{
        return false;
    }
}
private TNode minimum(TNode leaf){
    while(leaf.left!=null){
        leaf=leaf.left;
    }
    return leaf;
}
private TNode replace(TNode leaf){
    if (leaf.left!=null){
            leaf.left= replace(leaf.left);
            return leaf;
        }
        else
            return leaf.right;          
}
private TNode remove(int v, TNode t){
    if(t==null){
        return null;
    }
    if(v<t.element){
        t.left=remove(v,t.left);//branch left
    }
    else if(v>t.element){
        t.right=remove(v,t.right);//branch right
    }
    
    else {//when v==t.element
        //if the node we want to delete has 2 children:
        if(t.left!=null && t.right!= null){
            t.element=(minimum(t.right)).element;
            t.right = replace(t.right);
        }
        //if the node we want to delete has only left child
        else if(t.left!=null){
            t=t.left;
        }
        //if the node we want to delete has only right child
        else if(t.right!=null) {
            t=t.right;
            }
        else{// if the node we want to delete is a leaf 
            t=null;//sets the node to null
        }
    }
    return t;
}
//union of this BSTSet and s
public BSTSet union(BSTSet s){ 
    BSTSet UnionSet=new BSTSet();//allocating space for new set
    union(UnionSet, root);//adding elements from BSTSet 
    union(UnionSet, s.root);//adding elements from s
    return UnionSet;//returns union of both sets
}

private void union(BSTSet set , TNode t){
    if(t!= null){
        set.add(t.element);// uses the add method to add elements from both sets; without repetetion
        union(set, t.left);//branch left 
        union(set,t.right);//branch right 
    }
}

//intersection of this BSTSet and s
public BSTSet intersection(BSTSet s){
    BSTSet IntersectionSet=new BSTSet();//allocating space for new set
    intersection(IntersectionSet,s.root);//adding elements from s
    return IntersectionSet;//return intersection of both sets
}
private void intersection(BSTSet s, TNode t){
    if(t!=null){
        if(this.isIn(t.element)){//if element in s also exists in this BSTSet
            s.add(t.element);//we add that element to our new set
        }
        intersection(s,t.left);//branch left
        intersection(s,t.right);//branch right
    }
}
//Returns the size of this BSTSet
public int size(){
    return size(root);
}
private int size(TNode t){ 
    if(t == null)
        return 0;
    else{
        return size(t.left)+size(t.right)+1;//left subtree+right subtree+ root
    } 
}

//Returns the height of this BSTSet
public int height(){
    return height(root);
}
private int height(TNode t){
    if (t == null)
        return -1;//convention: height of empty tree is -1
    else{
        return Math.max(height(t.left)+1, height(t.right)+1);//height of left subtree + height of right subtree
      }
}

//Outputs the elements of this set to the console, in increasing order
public void printBSTSet(){
    if (root==null)
        System.out.println("The set is empty");
    else{
        System.out.print("The set elements are:");
        printBSTSet(root);
        System.out.print("\n");
    }
}

//Outputs to the console the elements stored in the subtree rooted in t, in increasing order
private void printBSTSet(TNode t){
    if(t!=null){
        printBSTSet(t.left);
        System.out.print(""+t.element+",");
        printBSTSet(t.right);
    }
}

//Print the integers in this BSTSet in increasing order (Stack Implementation & InOrder Traversal)
public void printNonRec(){
    if(root!=null){
        MyStack Stack = new MyStack();//allocating space for Stack
        TNode t = root;
        while(t!=null){//getting all elements on left; cause left has smaller elements
            Stack.push(t);//first push root in stack
            t=t.left;//branch left
        }
        while(!Stack.isEmpty()){
            t=Stack.pop();//pop element and return value
            System.out.print(t.element +",");
            if(t.right!=null){//getting all elements on right; starting with the smaller ones
                t=t.right;
                    while(t!=null){
                        Stack.push(t);
                        t=t.left;
                }
            }
        }
    }
}
public void printLevelOrder(){
    TNode t = root;
    if(t!=null){
        MyQueue Queue = new MyQueue();//allocating space for Queue
        Queue.enqueue(t);//enqueue root
        while(!Queue.isEmpty()){
                 TNode node = Queue.dequeue();//first enqueued -> first dequeued
                 System.out.print(node.element + ",");               
                 if(node.left != null){
                     Queue.enqueue(node.left);//enqueue left child
                 }  
                 if(node.right != null){
                     Queue.enqueue(node.right);//enqueue right child
                 }
             }
         }
    }
}
